## 和类组件对比

- 类组件需要继承，函数式组件不需要
- 类组件可以使用生命周期方法，函数式组件不能
- 类组件会被实例化，从而能使用实例化后的 this，并且可以基于 this 做很多事情，而函数式组件不能
- 类组件可以定义和维护 state，而函数式组件不可以

更推荐的做法是类组件和函数式组件配合使用，可以用类组件构造一个较大的 UI 模块，再通过函数式组件进行细粒度拆分并复用，这样轻重结合能更大地发挥 React 优势。

**函数式组件会捕获 render 内部的状态，这是两类组件最大的不同。**

## react hooks

react hooks 是一组能够使函数式组件更强大、更灵活的钩子。

### useState

为函数式组件引入状态。

useState 返回值是一个数组，第一个元素是对应的 state 变量，第二个元素是修改 state 变量的 API。

```jsx
const [state, setState] = useState(initialState)
```

### useEffect

允许函数式组件执行副作用操作。在一定程度上弥补了生命周期的缺失。

```jsx
useEffect(callback, []) // 第二个参数是依赖数组
```

1. 每一次渲染后都执行的副作用：传入回调函数，不传依赖数组

```jsx
useEffect(callback)
```

2. 仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数非闭包，同时传入一个空数组

```jsx
useEffect(() => {

}, [])
```

3. 仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且回调函数返回值是一个函数，同时传入一个空数组

```jsx
useEffect(() => {
  // A 逻辑在挂载阶段执行
  return () => {
    // B 逻辑在卸载阶段执行
  }
}, [])
```

useEffect 回调函数返回的函数被称为“清除函数”，所以在卸载阶段执行。

4. 每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数且返回了清除函数，同时不传第二个参数

```jsx
useEffect(() => {
  return () => {

  }
})
```

5. 根据一定的依赖条件触发的副作用：传入回调函数，同时传入非空数组

```jsx
useEffect(() => {
  return xxx // xxx 如果是清除函数，会在卸载时被执行
}, [num1, num2, num3])
```

## 设计 react hooks 带来了什么

1. 告别难以理解的 class（this 和 生命周期）
2. 解决业务逻辑难以拆分的问题（逻辑和生命周期耦合在一起，一个生命周期里会做很多件事情）
3. 使状态逻辑复用变得简单可行（）
4. 函数式组件从设计思想上来看更契合 React 的理念

## 使用 React Hooks 原则

1. 只在 React 函数中调用 Hook
2. 不要在循环、条件或嵌套函数中调用 Hook

Hooks 的本质是链表，mountState （首次渲染）构建链表并渲染，updateState 依次遍历链表并渲染。
